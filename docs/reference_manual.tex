%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Non-blocking Ada Reference Manual
%
% Copyright (C) 2007 Anders Gidenstam (andersg@mpi-inf.mpg.de)
%
%  Algorithms and Complexity Group
%  Max-Planck-Institut für Informatik
%  Stuhlsatzenhausweg 85
%  66123 Saarbrücken, Germany
%
% $Id: reference_manual.tex,v 1.3 2007/09/10 08:54:21 andersg Exp $
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[english,10pt]{book}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[english]{babel}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{graphicx}   % For importing graphics
\usepackage{moreverb}   % To be able to use the environment boxedverbatim
\usepackage{subfigure}  % To be able to use \subfigure
\usepackage{fancyhdr}
\usepackage{makeidx}    % To make an index
\usepackage{float}
\usepackage{a4wide}
\usepackage{listings}
\lstloadlanguages{Ada}
%\usepackage[chapter]{algorithm}
%\usepackage[noend]{algorithmic}
%\usepackage{color}
%\usepackage{psfig}
%\usepackage{psfrag}
%\usepackage{epsfig}

%%%%% Typesets operation and variable names in the main text.
\newcommand{\op}[1]{{\textsf{\textit{#1}}}}
\newcommand{\var}[1]{{\textsf{#1}}}
\newcommand{\code}[1]{{\textsf{\tt {#1}}}}

%%%%% Typesets keywords in code figures.
\newcommand{\kw}[1]{{\textbf{#1}}}
\newcommand{\term}[1]{{\emph{#1}}}

%%%%% for easy-to-undo modifications
\newcommand{\remove}[1]{{}}

%%%%% For eye-catching TODO notes, questions, etc
\newcommand{\todo}[1]{\noindent{\bf TODO:}{\sc #1}}
%\newcommand{\todo}[1]{{}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Document specific definitions

%% Library name
\newcommand{\nbada}{{\sc NbAda}}

%% Ada
\newcommand{\ada}{{\sc Ada}}

%% Program float environment
\floatstyle{ruled}
\newfloat{AdaProgram}{thp}{lop}
\floatname{AdaProgram}{Program}

%% Ada code environment
\newenvironment{AdaCode}
               {\begin{small}}
               {\end{small}}

%%%%% Make index
%\makeindex

%%%%%%%%%%%%%%%%%%%%%%%% EOD %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\selectlanguage{english}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Title page

\begin{titlepage}
  
  \title{%
    \Huge \nbada\\
    \vspace{5mm}
    \huge Non-blocking Algorithms and Data Structures Library\\
    \vspace{5mm}
    \huge Reference Manual
  }
  \author{%
    Anders Gidenstam  (andersg(at)mpi-inf.mpg.de)
  }

  \date{
    Draft \today\\
    \vspace{5mm}
    %%
    \vspace{12mm}
    Algorithms and Complexity Group\\
    Max-Planck-Institut f\"ur Informatik\\
    Stuhlsatzenhausweg 85\\
    66123 Saarbr\"ucken, Germany\\
    \vspace{12mm}
    Saarbr\"ucken, Germany, 2007
  }


  \maketitle
\end{titlepage}

\lstset{language=Ada,
        basicstyle=\footnotesize,
        numbers=left,
        numberstyle=\tiny,
        stepnumber=2,
        numbersep=5pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Data structures}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Atomic Objects}

\subsection{Large Register}

\cite{Pet83,LaGiHaPaTs:ESA04}

\subsubsection*{The package Atomic\_Single\_Writer\_Registers}

\begin{AdaCode}
\begin{lstlisting}
generic
   type Element_Type is private;

package NBAda.Atomic_Single_Writer_Registers is

   pragma Preelaborate (NBAda.Atomic_Single_Writer_Registers);

   type Atomic_1_M_Register (No_Of_Readers : Positive) is limited private;

   procedure Write (Register : in out Atomic_1_M_Register;
                    Value    : in     Element_Type);
   procedure Read  (Register  : in out Atomic_1_M_Register;
                    Reader_No : in     Positive;
                    Value     :    out Element_Type);

private

   ...  --  Implementation details.

end NBAda.Atomic_Single_Writer_Registers;
\end{lstlisting}
\end{AdaCode}

\subsection{Linearizable Snapshot}

\cite{Jayanti:2005:MWS}

\subsubsection*{The package Atomic\_Multiwriter\_Snapshots}

\begin{AdaCode}
\begin{lstlisting}
generic
   Max_Number_Of_Components : Natural;
   --  Maximum number of components in the snapshot.
   with package Process_Ids is
     new Process_Identification (<>);
   --  Process identification.
package NBAda.Atomic_Multiwriter_Snapshots is

   pragma Elaborate_Body;

   type Snapshot (<>) is private;

   function Scan return Snapshot;

   Maximum_Number_Of_Components_Exceeded : exception;

   generic
      --  Use pragma Atomic and pragma Volatile for Target.
      --  Element'Object_Size MUST be System.Word_Size.
      type Element is private;
   package Element_Components is

      type Element_Component is private;

      function Create (Default_Value : in Element) return Element_Component;

      procedure Write (To    : in Element_Component;
                       Value : in Element);

      function Read (Component : in Element_Component;
                     From      : in Snapshot) return Element;

   private

      ...  --  Implementation details.

   end Element_Components;

private

   ...  --  Implementation details.

end NBAda.Atomic_Multiwriter_Snapshots;
\end{lstlisting}
\end{AdaCode}

\subsection{Software Load-Linked/Store-Conditional for Objects}

\cite{Michael:2004:PLFLL}

\subsubsection*{The package Large\_Primitives}

\begin{AdaCode}
\begin{lstlisting}
generic
   Max_Number_Of_Links : Natural;
   --  Maximum number of simultaneous LL/SC per thread.
   with package Process_Ids is
     new Process_Identification (<>);
   --  Process identification.
package NBAda.Large_Primitives is

   package MR is < Implementation defined >

   generic
      type Element is private;
   package Load_Linked_Store_Conditional is

      type Shared_Element is limited private;

      function  Load_Linked (Target : in Shared_Element) return Element;
      function  Load_Linked (Target : access Shared_Element) return Element;

      function  Store_Conditional (Target : in     Shared_Element;
                                   Value  : in     Element) return Boolean;
      function  Store_Conditional (Target : access Shared_Element;
                                   Value  : in     Element) return Boolean;

      procedure Store_Conditional (Target : in out Shared_Element;
                                   Value  : in     Element);
      procedure Store_Conditional (Target : access Shared_Element;
                                   Value  : in     Element);


      function  Verify_Link (Target : in Shared_Element) return Boolean;
      function  Verify_Link (Target : access Shared_Element) return Boolean;


      procedure Initialize (Target : in out Shared_Element;
                            Value  : in     Element);
      procedure Initialize (Target : access Shared_Element;
                            Value  : in     Element);
      --  Note: Initialize is only safe to use when there are no
      --        concurrent updates.

   private

      ...  --  Implementation specific

   end Load_Linked_Store_Conditional;

   procedure Print_Statistics;

end NBAda.Large_Primitives;
\end{lstlisting}
\end{AdaCode}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Containers}

\subsection{Stacks}

\subsection{Queues}

\subsection{Dictionaries}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Support Packages}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Memory Reclamation Schemes}

\subsection{Safe reclamation of statically linked shared blocks}

Dereference of shared reference value, a.k.a link, contained in a
dereferenced \emph{statically linked} shared block is not guaranteed
to yield a valid reference value, the obtained value can point to
a block that has already been reclaimed.


\begin{AdaCode}
\begin{lstlisting}
package NBAda.Hazard_Pointers is

   type Managed_Node_Base is abstract tagged limited private;
   --  Inherit from this base type to create your own managed types.

   procedure Free (Object : access Managed_Node_Base) is abstract;

   generic
      type Managed_Node is new Managed_Node_Base with private;
   package Operations is

      type Shared_Reference is limited private;
      --  Note: All shared variables of type Shared_Reference MUST be
      --        declared atomic by 'pragma Atomic (Variable_Name);' .

      type Node_Access is access all Managed_Node;
      --  Note: There SHOULD NOT be any shared variables of type
      --        Node_Access.

      function  Dereference (Shared : access Shared_Reference)
                            return Node_Access;
      --  Note:

      procedure Release     (Local  : in Node_Access);
      --  Note: Each dereferenced shared pointer MUST be released
      --        eventually.

      procedure Delete      (Local  : in Node_Access);
      --  Note: Delete may only be called when the caller can
      --        guarantee that there are NO and WILL NOT BE any more shared
      --        references to the node. The memory management scheme makes
      --        sure the node is not freed until all local references have
      --        been released.

      function  Boolean_Compare_And_Swap (Shared    : access Shared_Reference;
                                          Old_Value : in     Node_Access;
                                          New_Value : in     Node_Access)
                                         return Boolean;

      procedure Value_Compare_And_Swap   (Shared    : access Shared_Reference;
                                          Old_Value : in     Node_Access;
                                          New_Value : in out Node_Access);

      procedure Void_Compare_And_Swap    (Shared    : access Shared_Reference;
                                          Old_Value : in     Node_Access;
                                          New_Value : in     Node_Access);


      procedure Initialize (Shared    : access Shared_Reference;
                            New_Value : in     Node_Access);
      --  Note: Initialize is only safe to use when there are no
      --        concurrent updates.

   private

      type Shared_Reference is new Node_Access;
      --   pragma Atomic (Shared_Reference);
      --   pragma Volatile (Shared_Reference);
      --  Note: All shared variables of type Shared_Reference MUST be
      --        declared atomic by 'pragma Atomic (Variable_Name);' .

   end Operations;


   type Shared_Reference_Base is limited private;
   --  For type separation between shared references to different
   --  managed types derive your own shared reference types from
   --  Shared_Reference_Base and instantiate the memory management
   --  operation package below for each of them.

   generic

      type Managed_Node is
        new Managed_Node_Base with private;

      type Shared_Reference is new Shared_Reference_Base;
      --  All shared variables of type Shared_Reference MUST be declared
      --  atomic by 'pragma Atomic (Variable_Name);' .

   package Reference_Operations is

      type Node_Access is access all Managed_Node;
      --  Note: There SHOULD NOT be any shared variables of type
      --        Node_Access.

      type Private_Reference is private;
      --  Note: There SHOULD NOT be any shared variables of type
      --        Private_Reference.
      Null_Reference : constant Private_Reference;
      --  Note: A marked null reference is not equal to Null_Reference.

      function  Dereference (Link : access Shared_Reference)
                            return Private_Reference;

      procedure Release (Node : in Private_Reference);

      function  "+"     (Node : in Private_Reference)
                        return Node_Access;
      function  Deref   (Node : in Private_Reference)
                        return Node_Access;

      function  Boolean_Compare_And_Swap (Link      : access Shared_Reference;
                                          Old_Value : in Private_Reference;
                                          New_Value : in Private_Reference)
                                         return Boolean;

      procedure Void_Compare_And_Swap    (Link      : access Shared_Reference;
                                          Old_Value : in Private_Reference;
                                          New_Value : in Private_Reference);

      procedure Delete  (Node : in Private_Reference);

      procedure Store   (Link : access Shared_Reference;
                         Node : in Private_Reference);
      --  Note: Store is only safe to use when there cannot be any
      --        concurrent updates to Link.

      generic
         type User_Node_Access is access Managed_Node;
         --  Select an appropriate (preferably non-blocking) storage
         --  pool by the "for User_Node_Access'Storage_Pool use ..."
         --  construct.
         --  Note: The nodes allocated in this way must have an
         --        implementation of Free that use the same storage pool.
      function Create return Private_Reference;
      --  Creates a new User_Node and returns a safe reference to it.

      procedure Mark      (Node : in out Private_Reference);
      function  Mark      (Node : in     Private_Reference)
                          return Private_Reference;
      procedure Unmark    (Node : in out Private_Reference);
      function  Unmark    (Node : in     Private_Reference)
                          return Private_Reference;
      function  Is_Marked (Node : in     Private_Reference)
                          return Boolean;

      function  Is_Marked (Node : in     Shared_Reference)
                          return Boolean;

      function "=" (Link : in     Shared_Reference;
                    Ref  : in     Private_Reference) return Boolean;
      function "=" (Ref  : in     Private_Reference;
                    Link : in     Shared_Reference) return Boolean;

   private

      ...  --  Implementation details.

   end Reference_Operations;

   procedure Print_Statistics;

private

   ...  --  Implementation details.

end NBAda.Hazard_Pointers;
\end{lstlisting}
\end{AdaCode}


\cite{Fraser:2004:PLF,Hart:2005:CPMR}

\cite{Michael:2002:SMR,Michael:2004:SMR}

\subsection{Safe reclamation of dynamically linked shared blocks}

Dereference of a shared reference value, a.k.a link, contained in a
dereferenced \emph{dynamically linked} shared block is guaranteed
to yield a valid reference value.


\cite{Herlihy:2002:ROP,HerlihyLuMaMo:2002:DSLF,HerlihyLuMaMo:2005:NBMM}

\cite{GiPaSuTs:2005:LFGC}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Memory Allocation Pools}

\cite{IBM:1983}

\subsubsection*{The package NBAda.Lock\_Free\_Fixed\_Size\_Storage\_Pools}

\begin{AdaCode}
\begin{lstlisting}
with System.Storage_Elements;
with System.Storage_Pools;

package NBAda.Lock_Free_Fixed_Size_Storage_Pools is

   pragma Preelaborate (NBAda.Lock_Free_Fixed_Size_Storage_Pools);

   type Block_Count is range 0 .. 2**16 - 1;

   type Lock_Free_Storage_Pool
     (Pool_Size  : Block_Count;
      Block_Size : System.Storage_Elements.Storage_Count) is
     new System.Storage_Pools.Root_Storage_Pool with private;

   procedure Allocate
     (Pool                     : in out Lock_Free_Storage_Pool;
      Storage_Address          :    out System.Address;
      Size_In_Storage_Elements : in     System.Storage_Elements.Storage_Count;
      Alignment                : in     System.Storage_Elements.Storage_Count);

   procedure Deallocate
     (Pool                     : in out Lock_Free_Storage_Pool;
      Storage_Address          : in     System.Address;
      Size_In_Storage_Elements : in     System.Storage_Elements.Storage_Count;
      Alignment                : in     System.Storage_Elements.Storage_Count);

   function Storage_Size (Pool : Lock_Free_Storage_Pool)
                         return System.Storage_Elements.Storage_Count;

   function Validate (Pool : Lock_Free_Storage_Pool)
                     return Block_Count;

   function Belongs_To (Pool            : Lock_Free_Storage_Pool;
                        Storage_Address : System.Address)
                       return Boolean;

   Storage_Exhausted    : exception;
   Implementation_Error : exception;

private

   ...  --  Implementation details.

end NBAda.Lock_Free_Fixed_Size_Storage_Pools;
\end{lstlisting}
\end{AdaCode}

\cite{Dice:2002:MLFM,Michael:2004:SLFDMA,GiPaTs:2005:AMLF,SchneiderAnNi:2006:SLCMMA}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hardware Abstraction Interface}

\subsubsection*{The package Primitives}

\begin{AdaCode}
\begin{lstlisting}
with System;

package NBAda.Primitives is

   pragma Preelaborate (Primitives);

   Not_Implemented : exception;

   procedure Membar;

   type Standard_Unsigned is mod 2**System.Word_Size;
   pragma Atomic (Standard_Unsigned);

   generic
      --  Element'Object_Size MUST be System.Word_Size.
      type Element is private;
   function Standard_Atomic_Read (Target : access Element) return Element;

   generic
      --  Element'Object_Size MUST be System.Word_Size.
      type Element is private;
   procedure Standard_Atomic_Write (Target : access Element;
                                    Value  : in     Element);

   generic
      --  Element'Object_Size MUST be System.Word_Size.
      type Element is private;
   procedure Standard_Compare_And_Swap (Target    : access Element;
                                        Old_Value : in     Element;
                                        New_Value : in out Element);

   generic
      --  Element'Object_Size MUST be System.Word_Size.
      type Element is private;
   function Standard_Boolean_Compare_And_Swap (Target    : access Element;
                                               Old_Value : in     Element;
                                               New_Value : in     Element)
                                              return Boolean;

   generic
      --  Element'Object_Size MUST be System.Word_Size.
      type Element is private;
   procedure Standard_Void_Compare_And_Swap (Target    : access Element;
                                             Old_Value : in     Element;
                                             New_Value : in     Element);

   procedure Fetch_And_Add (Target    : access Standard_Unsigned;
                            Increment : in     Standard_Unsigned);

   function  Fetch_And_Add (Target    : access Standard_Unsigned;
                            Increment : in     Standard_Unsigned)
                           return Standard_Unsigned;


   type Unsigned_32 is mod 2**32;
   pragma Atomic (Unsigned_32);

   generic
      --  Element'Object_Size MUST be 32.
      type Element is private;
   function Atomic_Read_32 (Target : access Element) return Element;

   generic
      --  Element'Object_Size MUST be 32.
      type Element is private;
   procedure Atomic_Write_32 (Target : access Element;
                              Value  : in     Element);

   generic
      --  Element'Object_Size MUST be 32.
      type Element is private;
   procedure Compare_And_Swap_32 (Target    : access Element;
                                  Old_Value : in     Element;
                                  New_Value : in out Element);

   generic
      --  Element'Object_Size MUST be 32.
      type Element is private;
   function Boolean_Compare_And_Swap_32 (Target    : access Element;
                                         Old_Value : in     Element;
                                         New_Value : in     Element)
                                        return Boolean;

   generic
      --  Element'Object_Size MUST be 32.
      type Element is private;
   procedure Void_Compare_And_Swap_32 (Target    : access Element;
                                       Old_Value : in     Element;
                                       New_Value : in     Element);

   procedure Fetch_And_Add_32 (Target    : access Unsigned_32;
                               Increment : in     Unsigned_32);

   function  Fetch_And_Add_32 (Target    : access Unsigned_32;
                               Increment : in     Unsigned_32)
                              return Unsigned_32;

   type Unsigned_64 is mod 2**64;
   pragma Atomic (Unsigned_64);

   generic
      --  Element'Object_Size MUST be 64.
      type Element is private;
   function Atomic_Read_64 (Target : access Element) return Element;

   generic
      --  Element'Object_Size MUST be 64.
      type Element is private;
   procedure Atomic_Write_64 (Target : access Element;
                              Value  : in     Element);

   generic
      --  Element'Object_Size MUST be 64.
      type Element is private;
   procedure Compare_And_Swap_64 (Target    : access Element;
                                  Old_Value : in     Element;
                                  New_Value : in out Element);

   generic
      --  Element'Object_Size MUST be 64.
      type Element is private;
   function Boolean_Compare_And_Swap_64 (Target    : access Element;
                                         Old_Value : in     Element;
                                         New_Value : in     Element)
                                        return Boolean;

   generic
      --  Element'Object_Size MUST be 64.
      type Element is private;
   procedure Void_Compare_And_Swap_64 (Target    : access Element;
                                       Old_Value : in     Element;
                                       New_Value : in     Element);

   procedure Fetch_And_Add_64 (Target    : access Unsigned_64;
                               Increment : in     Unsigned_64);

   function  Fetch_And_Add_64 (Target    : access Unsigned_64;
                               Increment : in     Unsigned_64)
                              return Unsigned_64;

end NBAda.Primitives;
\end{lstlisting}
\end{AdaCode}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% References and index.
\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{alpha}
\bibliography{references}

%\printindex


\end{document}